<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ベジタリアン対応レストラン検索</title>
  <!-- CSP を緩和：Google Maps + Google Fonts を許可 -->
  <meta http-equiv="Content-Security-Policy"
  content="
    default-src        'self';
    script-src         'self' 'unsafe-inline' 'unsafe-eval'
                       https://maps.googleapis.com
                       https://maps.gstatic.com;
    style-src          'self' 'unsafe-inline'
                       https://fonts.googleapis.com
                       https://maps.gstatic.com;
    img-src            'self' data:
                       https://maps.googleapis.com
                       https://maps.gstatic.com
                       https://maps.google.com;
    connect-src        'self'
                       https://maps.googleapis.com
                       https://maps.gstatic.com
                       https://asia-northeast1-blissful-shore-458002-e9.cloudfunctions.net;
    font-src           'self' data:
                       https://fonts.gstatic.com;
  ">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h2>目的地近辺のベジタリアン料理のお店</h2>
  <div id="controls">
    <input id="location-input" type="text" placeholder="目的地を入力してください" />
    <button id="search-btn">検索</button>
  </div>
  <p class="note">
    ※ 「❗️」マークは「ベジタリアン」「ヴィーガン」などの検索結果に出るものの  
    ビジネスプロフィールに「ベジタリアン料理があるお店」の表記がないお店。  
    ベジタリアンメニューがあるかどうかはとりわけ要確認。
  </p>
  <div id="map"></div>
  <ul id="results"></ul>

  <script>
      let map, service, autocomplete, distanceService, originLocation, originMarker;

      function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: 35.681236, lng: 139.767125 },
        zoom: 14
      });
      service = new google.maps.places.PlacesService(map);
      // DistanceMatrixService を初期化
      distanceService = new google.maps.DistanceMatrixService();
      autocomplete = new google.maps.places.Autocomplete(
        document.getElementById("location-input")
      );
      autocomplete.bindTo("bounds", map);

      document.getElementById("search-btn").addEventListener("click", () => {
        const place = autocomplete.getPlace();
        if (!place || !place.geometry) {
          alert("候補から場所を選択してください");
          return;
        }
        // originLocation に検索地点を保存
        originLocation = place.geometry.location;
        map.setCenter(place.geometry.location);
        map.setZoom(15);
        multiKeywordSearch(place.geometry.location, ['vegetarian','vegan', 'ヴィーガン', 'ベジタリアン', '素食', 'マクロビ', 'マクロビオティック']);
      });
    }

    function multiKeywordSearch(location, keywords) {

    let overLimit = false;
    const allPromises = keywords.map(kw => new Promise(resolve => {
    service.nearbySearch({
      location,
      radius: 1500,
      type: 'restaurant',
      keyword: kw
    }, (results, status) => {
      if (status === google.maps.places.PlacesServiceStatus.OVER_QUERY_LIMIT) {
        overLimit = true;
        resolve([]);  // 空配列返して処理だけ続ける
      }
      else if (status === google.maps.places.PlacesServiceStatus.OK) {
        resolve(results);
      }
      else {
        resolve([]);
      }
    });
  }));


   Promise.all(allPromises).then(resultsArray => {
    console.log('multiKeyword results:', resultsArray);
    if (overLimit) {
      // ボタンを無効化して以降の検索をストップ
      const btn = document.getElementById('search-btn');
      btn.disabled = true;
      alert('無料クォータを超過しました。新しい検索はできません。');
      return;
    }
    // 手動で flatten
    const allPlaces = resultsArray.reduce((acc, arr) => acc.concat(arr), []);
    // place_id で重複除去
    const merged = [];
    const seen   = new Set();
    allPlaces.forEach(p => {
      if (!seen.has(p.place_id)) {
        seen.add(p.place_id);
        merged.push(p);
      }
    });
      // 結果を drawResults に渡す（ステータスOK扱い）
      drawResults(merged, google.maps.places.PlacesServiceStatus.OK);
    });
  }

  function sendHeightToParent() {
  const h = document.documentElement.scrollHeight;
  // '*' ではなくあなたの Studio 側ドメインを指定しておくのが望ましいです
  window.parent.postMessage({ type: 'resize', height: h }, '*');
}

 const PROXY_URL =
    'https://asia-northeast1-blissful-shore-458002-e9.cloudfunctions.net/getVegetarianFlag';

  // メモリ上キャッシュ用オブジェクト
  const vegetarianFlagCache = {};

  /**
   * place_id を渡すと Cloud Function 経由で
   * serves_vegetarian_food フラグを返す
   */
  async function fetchVegetarianFlag(placeId) {
   // 1) まずメモリキャッシュをチェック
   if (vegetarianFlagCache[placeId] !== undefined) {
     return vegetarianFlagCache[placeId];
   }
   // 2) localStorage キャッシュをチェック
   const storageKey = `vegFlag_${placeId}`;
   const stored = localStorage.getItem(storageKey);
  if (stored !== null && stored !== 'undefined') {
    try {
      const flag = JSON.parse(stored);
      vegetarianFlagCache[placeId] = flag;
      return flag;
    } catch (e) {
      // 万が一 parse に失敗したらキャッシュクリアしてフェッチにフォールバック
      localStorage.removeItem(storageKey);
    }
  }

    try {
      const res = await fetch(
        `${PROXY_URL}?place_id=${encodeURIComponent(placeId)}`
      );
      if (!res.ok) {
        console.error('Proxy error:', await res.text());
        return undefined;
      }
      const json = await res.json();
      const flag = json.serves_vegetarian_food;
      if (typeof flag === 'boolean') {
        // boolean のときだけ localStorage に保存
        localStorage.setItem(storageKey, JSON.stringify(flag));
      }
      // 3) フェッチ結果をキャッシュに保存
      vegetarianFlagCache[placeId] = flag;
      localStorage.setItem(storageKey, JSON.stringify(flag));
      return flag;
    } catch (e) {
      console.error('Network error fetching vegetarian flag', e);
      return undefined;
    }
  }

function drawResults(places, status) {
  console.log('drawResults called with', places, status);
  // ■ フィルタ前の検索結果を全件ログに出力
  console.table(places.map(p => ({
    name:     p.name,
    types:    p.types
  })));
  if (status !== google.maps.places.PlacesServiceStatus.OK) {
    console.warn('検索失敗:', status);
    return;
  }

  const resultsEl = document.getElementById('results');
  resultsEl.innerHTML = '';


  // 1) 直線距離フィルタ＋レストランフィルタ
  const filtered = places.filter(p => {
    if (!p.types?.includes('restaurant')) return false;
    const dist = google.maps.geometry.spherical.computeDistanceBetween(
      originLocation,
      p.geometry.location
    );
    return dist <= 1500;
  });

    
  // 2. getDetails を Promise 化して並列取得
  const detailPromises = filtered.map(p => new Promise(resolve => {
    service.getDetails({
      placeId: p.place_id,
      // ベジタリアンフラグは REST 経由で取得するため、
      // ここでは Maps JS API がサポートするフィールドのみ指定
      fields: [
        'name',
        'vicinity',
        'geometry',
        'place_id'
      ]
    }, async (detail, ds) => {
      if (
        ds === google.maps.places.PlacesServiceStatus.OK &&
        detail.geometry &&
        detail.geometry.location
      ) {
        try {
          // Cloud Function 経由でベジタリアンフラグを取得
          const flag = await fetchVegetarianFlag(detail.place_id);
          // detail にプロパティとして追加
          detail.servesVegetarianFood = flag;
        } catch (e) {
          console.error('Flag fetch error', e);
          detail.servesVegetarianFood = undefined;
        }
        resolve(detail);
      } else {
        resolve(null);
      }
    });
  }));

  Promise.all(detailPromises).then(detailsRaw => {
    console.log('▶︎ detailPromises resolved, items:', detailsRaw.length);

    // 3. null を除去

    const details = detailsRaw.filter(d => d !== null);

    if (!details.length) {
      resultsEl.textContent = '該当する店舗が見つかりませんでした。';
      sendHeightToParent();
      return;
    }

    // 4. Distance Matrix で徒歩時間取得
    const destinations = details.map(d => d.geometry.location);
    const CHUNK_SIZE   = 20;  // ← 1チャンクあたりの件数。25 以下かつ origins×destinations≤100 を意識

    // チャンクに分割するヘルパー
    function chunkArray(arr, size) {
      const chunks = [];
      for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i+size));
      }
      return chunks;
    }


  (async () => {
  // 1) まずチャンク化
  const destChunks = chunkArray(destinations, CHUNK_SIZE);
  // 2) 各チャンクごとに Distance Matrix を await で回す
  const matrixResults = [];
  for (const chunk of destChunks) {
    // eslint-disable-next-line no-await-in-loop
    const dmRes = await new Promise(resolve => {
      distanceService.getDistanceMatrix({
        origins:      [ originLocation ],
        destinations: chunk,
        travelMode:   google.maps.TravelMode.WALKING,
        unitSystem:   google.maps.UnitSystem.METRIC
      }, (res, status) => resolve({ res, status }));
    });
    if (dmRes.status !== google.maps.DistanceMatrixStatus.OK) {
      console.warn('DistanceMatrix failed for chunk:', dmRes.status);
      // 必要なら break してフォールバック描画へ
      break;
    }
    matrixResults.push(...dmRes.res.rows[0].elements);
  }

  // 3) matrixResults は元の順序で element オブジェクトが並ぶので、
  //    details[i] と結びつけて enriched 配列を作る
  const enriched = details.map((d, i) => {
    const el = matrixResults[i] || {};
    return {
      detail:        d,
      distanceText:  el.distance?.text  || '―',
      durationText:  el.duration?.text  || '―',
      durationValue: el.duration?.value || Infinity
    };
  }).sort((a, b) => a.durationValue - b.durationValue);

  // 6. マーカー＆リスト描画（徒歩時間順）
  enriched.forEach(item => {
    console.log('Appending list item for', item.detail.name);
    const d = item.detail;
    const needsConfirm = !d.hasOwnProperty('servesVegetarianFood') || d.servesVegetarianFood === false;

  
    // アイコン定義
    const defaultIcon = {
      url: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
      scaledSize: new google.maps.Size(32, 32)
    };
    const hoverIcon = {
      url: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
      scaledSize: new google.maps.Size(48, 48)
    };



    // 店名・住所・距離を描画する前に
    const marker = new google.maps.Marker({
      position: d.geometry.location,
      map,
      icon: defaultIcon
    }); 

    const mapsUrl = `https://www.google.com/maps/search/?` + 
    new URLSearchParams({
       api:             '1',
       query:           d.name,          // e.g. "Morricone caffè italiano"
       query_place_id:  d.place_id
     }).toString();

    // 1) <li> は既に flex container
    const li = document.createElement('li');
    li.classList.add('result-item');
    li.style.cursor = 'pointer';
    li.addEventListener('click', () => {
      window.open(mapsUrl, '_blank');
    });

    // マーカー上での hover → マーカー拡大 ＆ li にクラス付与
    marker.addListener('mouseover', () => {
      marker.setIcon(hoverIcon);
      li.classList.add('hover');
    });
    marker.addListener('mouseout', () => {
      marker.setIcon(defaultIcon);
      li.classList.remove('hover');
    });

    // すでにある、li 上での hover → マーカー拡大処理
    li.addEventListener('mouseover', () => marker.setIcon(hoverIcon));
    li.addEventListener('mouseout',  () => marker.setIcon(defaultIcon));

    // 2) 店名カラム
    const nameDiv = document.createElement('div');
    nameDiv.classList.add('item-name');

    // → 要確認フラグが立っていれば先頭に赤いビックリを追加
    if (needsConfirm) {
      const emoji = document.createElement('span');
      emoji.textContent = '❗️ ';
      // optional: emoji.style.color = 'red';
      nameDiv.appendChild(emoji);
    }

    const a = document.createElement('a');
    a.textContent = d.name;
    a.href        = mapsUrl;
    a.target      = '_blank';
    a.rel         = 'noopener';
    a.style.textDecoration = 'none';
    a.style.color = 'inherit';
    nameDiv.appendChild(a);

    // 3) 住所カラム
    const vicinityDiv = document.createElement('div');
    vicinityDiv.classList.add('item-vicinity');
    vicinityDiv.textContent = d.vicinity;

    // 4) 距離＆時間カラム
    const distDiv = document.createElement('div');
    distDiv.classList.add('item-distance');
    distDiv.textContent = `目的地からの距離 ${item.distanceText}、約${item.durationText}`;

    // 5) li に append
    li.append(nameDiv, vicinityDiv, distDiv);
    resultsEl.appendChild(li);
    console.log('▶︎ finished appending', resultsEl.children.length, 'items');
    });

      // 7. 親ページへ高さを通知
      sendHeightToParent();
    })();
  });
}

</script>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDqBaGedqbzQ5ad-6_0-_JNKy2BDILsqGA&libraries=places,geometry&callback=initMap">
</script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const h2  = document.querySelector('h2');
    const map = document.getElementById('map');
    // h2 の高さ＋下マージンを計算
    const style      = getComputedStyle(h2);
    const h2Height   = h2.getBoundingClientRect().height;
    const marginBot  = parseFloat(style.marginBottom);
    map.style.top    = `${h2Height + marginBot}px`;
  });
</script>
</body>
</html>
